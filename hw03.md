# 1
Write out variables x, y and z in binary code
1) int8_t x = 67; int8_t y = -7; int8_t z = y - x;

x=01000011,y=11111001,z=10110110

2) int8_t x = 0xd3;

oxd3=211，溢出错误

3) uint8_t x= 0xd3;

x=11010011

4) int8_t x = 127; int8_t y = -7; int8_t z = y – x;

x=01111111,y=11111001,z溢出

5) float x = 1.125;

x=1.001

6) float x = 23.0;

x=10111

7) float x = 0.45;

x精度误差

# 2
1) Method of complements

In mathematics and computing, the method of complements is a technique used to subtract one number from another using only addition of positive numbers. This method was commonly used in mechanical calculators and is still used in modern computers.

2) Byte

The byte is a unit of digital information that most commonly consists of eight bits, representing a binary number. 

3) Integer (computer science)

In computer science, an integer is a datum of integral data type, a data type that represents some range of mathematical integers. 

4) Floating point

In computing, floating-point arithmetic (FP) is arithmetic using formulaic representation of real numbers as an approximation so as to support a trade-off between range and precision. 

# 3
1) 请证明：二进制的负数（two‘s complement of X）等于 X 的 ones’complement ＋ 1（即，X每位求反加1）

证明：取任意的一个负数x=-(a7*2^6+a6*2^5+a5*2^4+a4*2^3+a3*2^2+a2*2^1+a1)且ai=0/19(1=<i<=7)

所以x=1a7a6a5a4a3a2a1；-x=0a7a6a5a4a3a2a1

又因为八位二进制“模”为2^8=1 0000 0000

所以由补码定义可得x的补码为1 0000 0000-(-x)

x的反码为0(1-a7)(1-a6)(1-a5)(1-a4)(1-a3)(1-a2)(1-a1)

x的反码加1为y=1(1-a7)(1-a6)(1-a5)(1-a4)(1-a3)(1-a2)(1-a1)+00000001

又因为y+(-x)=1 0000 0000

所以y即为x的补码

得证 补码=反码+1

2) Int8_t x = - 017; 请用8进制描述变量 x。在c中017即(017)8

0361

# 4
阅读维基百科” Two‘s complement”的内容，特别是Sign extension小节内容。
1) C程序： ：int8_t x = -0x1f; int y = x; 请用16进制描述变量 x 和 y，并说明 inty = x 的计算过程。

x=0xe1

x=0xe1;x=11100001B=-97；y=1111 1111 1111 1111 1111 1111 1001 1111=0xffffffe1

2) 请用数学证明，为什么可以这么计算。


证法一：

首先证明数字为正数和0的情况：

设现有一二进制编码：0X1X2…..Xn， X∈{0，1}

显然，其对应数值即为 (X1X2…..Xn)2， X∈{0，1}

当需要对其进行Sign Extension至m位时（m>n+1），只需要在其左边加m-n-1个0

扩展后的编码为：000……000X1X2…..Xn (共m位，且X∈{0，1})

而X1左边的0并不会影响其和其右边的数字的值

所以显然，扩展后的编码对应数值也为 (X1X2…..Xn)2， X∈{0，1}

下证除了范围内最小负数以外的负数：

所选集合内的每个负数都可以找到对应的正数

任取一个负数1X1X2…..Xn， X∈{0，1}

则其必然有一对应正数 0X1X2…..Xn， X∈{0，1}

由对正数的证明可知，对该正数进行扩展后，得到的编码为：000……000X1X2…..Xn (共m位，且X∈{0，1})

再对该数取其Two’s complement，得到扩展后的原负数的编码为：
111...11(1-x1)..(1-xn)+0000...1

最后证明最小负数100……000(n个0)：

100……000(n个0)=100……001(共n+1位数)-1

而由对其余负数的证明可知，对100……001(共n+1位数)扩展后，得到的编码为111……11100……001(共m位数)

再减一之后，得到100……000(n个0)扩展后的编码：111……11100……000(共n个0，且共m位数)

综上所述，对任一 二进制 编码进行Sign Extension时，只需要在左边添加其编码最左一位的数字。

证法二：

由二进制补码的性质可知

一个正数编码的最左边的数字必然是0；一个负数编码的最左边的数字必然是1。

一个正数的绝对值是该数字与0的“距离”；一个负数的绝对值是该数字与2^n的“距离”；

我们需要保证一个编码在Sign Extension前后的绝对值不变。

因此：

记正数或0的绝对值为P，负数的绝对值为Q；

设有一二进制编码X，扩展前有n位，扩展后有m位；（不考虑溢出）

正数或0：

扩展前：X=000….000(n个0)+P

扩展后：X=000….000(m个0)+P=000…..0000(m-n个0)000…..000(n个0)+P

负数：

扩展前：X=2n-Q=111……111(n个1)-Q+1=111……111(n个1)-(Q-1)

扩展后：X=2m-Q=111……111(m个1)-Q+1=111……111(m-n个1)111……111(n个1)-(Q-1)

得证

推论：

由证明二可以看出，这一结论仅仅只针对二进制，因为在其余数字系统中，当求A^n-Q时，其结果左端的数字应该是该进制中最高的单位数字。而正因为二进制这一特性，使得其在扩展时，计算机只需要判断其最左端一位数字是多少，而其余进制则需要将数字与此时定义的范围大小的一半进行比大小，再进行扩展，二进制的优越性再一次体现出来。


# 5
 NaN 

 In computing, NaN, standing for not a number, is a numeric data type value representing an undefined or unrepresentable value, especially in floating-point calculations.


